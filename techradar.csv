name,ring,quadrant,isNew,description
Applying product management to internal platforms,Adopt,Techniques,FALSE,<p>More and more companies are building internal platforms to roll out new digital solutions quickly and efficiently. Companies that succeed with this strategy are <strong>applying product management to internal platforms</strong>. This means establishing empathy with internal consumers (the development teams) and collaborating with them on the design. Platform product managers create roadmaps and ensure the platform delivers value to the business and enhances the developer experience. Unfortunately, we're also seeing less successful approaches, where teams create a platform in the void, based on unverified assumptions and without internal customers. These platforms, often despite aggressive internal tactics, end up being underutilized and a drain on the organization's delivery capability. As usual, good product management is all about building products that consumers love.</p>
.NET Core,Adopt,Platforms,FALSE,<p>We previously had <strong>.NET Core</strong> in Adopt, indicating that it had become our default for .NET projects. But we felt it's worth again calling attention to .NET Core. With the release of .NET Core 3.<em>x</em> last year, the bulk of the features from .NET Framework have now been ported into .NET Core. With the announcement that <a href="https://devblogs.microsoft.com/dotnet/introducing-net-5">.NET Framework is on its last release</a>, Microsoft have reinforced the view that <a href="https://devblogs.microsoft.com/dotnet/net-core-is-the-future-of-net/">.NET Core is the future of .NET</a>. Microsoft has done a lot of work to make .NET Core <a href="https://devblogs.microsoft.com/dotnet/using-net-and-docker-together-dockercon-2019-update/">container friendly</a>. Most of our .NET Core–based projects target Linux and are often deployed as containers. The upcoming <a href="https://devblogs.microsoft.com/dotnet/introducing-net-5/">.NET 5</a> release looks promising, and we're looking forward to it.</p>
Cypress,Adopt,Tools,FALSE,<p><strong><a href="http://www.cypress.io/">Cypress</a></strong> is still a favorite among our teams where developers manage end-to-end tests themselves, as part of a healthy <a href="https://martinfowler.com/articles/practical-test-pyramid.html#End-to-endTests">test pyramid</a>, of course. We decided to call it out again in this Radar because recent versions of Cypress have added <a href="https://cypress.io/blog/2020/02/06/introducing-firefox-and-edge-support-in-cypress-4-0/">support for Firefox</a>, and we strongly suggest testing on multiple browsers. The dominance of Chrome and Chromium-based browsers has led to a worrying trend of teams seemingly only testing with Chrome which can lead to <a href="https://twitter.com/mike_conley/status/1245797292453609478">nasty surprises</a>.</p>
React Hooks,Adopt,languages-and-frameworks,FALSE,<p><strong><a href="https://reactjs.org/docs/hooks-intro.html">React Hooks</a></strong> have introduced a new approach to managing stateful logic; given React components have always been closer to functions than classes, Hooks have embraced this and brought state to the functions, instead of taking function as methods to the state with classes. Based on our experience, Hooks improve reuse of functionality among components and code readability. Given Hooks’ testability improvements, using <a href="https://reactjs.org/docs/test-renderer.html">React Test Renderer</a> and <a href="/radar/languages-and-frameworks/react-testing-library">React Testing Library</a>, and their growing community support, we consider them our approach of choice.</p>
